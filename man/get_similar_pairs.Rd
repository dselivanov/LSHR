% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LSHR.R, R/cosine.R
\name{get_similar_pairs}
\alias{get_similar_pairs}
\alias{get_similar_pairs_cosine}
\title{Calculating candidate pairs using locality sensitive hashing.}
\usage{
get_similar_pairs(X, bands_number, rows_per_band, distance = c("cosine",
  "jaccard"), seed = 1L, verbose = FALSE, mc.cores = 1, ...)

get_similar_pairs_cosine(X, bands_number, rows_per_band, seed = 1L,
  verbose = FALSE, mc.cores = 1, n_band_join = bands_number, ...)
}
\arguments{
\item{X}{input matrix - sparse or dense}

\item{bands_number}{number of bands for LSH algorithm - tradeoff between precision and
number of false positive candidates. See \link{get_s_curve} for details.}

\item{rows_per_band}{number of rows in each band for LSH algorithm - tradeoff between precision and
number of false positive candidates. See \link{get_s_curve} for details.
For "cosine" distance due to performance reasons (bit arifmetics) only values less than 32 are supported.}

\item{distance}{on of "cosine" or "jaccard" - how to measure distance between rows of input matrix}

\item{seed}{random seed for reproducibility}

\item{verbose}{\code{logical} print lsh process information.
(such as expected false positive rate, false negative rate,timings, etc.)}

\item{mc.cores}{number of cores to use for bands processing - random projection and candidate selection
(this is embrassingly parallel task - can be done independently for each band).
Most epensive operations - random projection. It is itself parallelized with OpenMP, so when \code{mc.cores > 1}
random projection becomes single threaded. \bold{usually we recommend use \code{mc.cores = 1}} and rely on internal
OpenMP parallelism. Candidate selection which not trivially parallelizable is not usually a bottleneck.}

\item{...}{other parameters to \code{mclapply} (used if \code{mc.cores > 1} )}

\item{n_band_join}{calculate in how many bands signatures became same. Since each bucket is independant obvious way is
to calculate this stastics at the end (by default), so we will do it only once. On the other side we can calculate it
each \code{n_band_join} so we can save some memory (if this becomes a issue).
\bold{in most cases we recommend to use default value for this parameter}.}
}
\value{
pairs of candidates with similarity => \code{similarity} -
\code{\link{data.table}} with 3 colums: id1, id2, N -
index of first candidate, index of second candidate,
and number of buckets where they share same value. The latter provided only for information.
(Intutition is following: the bigger N - the stronger similarity)
}
\description{
For a given matrix function generate indices of similar rows.
}
\examples{
\dontrun{
library(text2vec)
library(LSHR)
library(Matrix)
data("movie_review")
it <- itoken(movie_review$review, preprocess_function = tolower,
tokenizer = word_tokenizer)
dtm <- create_dtm(it, hash_vectorizer())
dtm = as(dtm, "RsparseMatrix")
pairs = get_similar_pairs(dtm, bands_number = 4, rows_per_band = 32,
distance = 'cosine', verbose = TRUE)
pairs[order(-N)]
}
}

